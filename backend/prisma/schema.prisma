// Prisma schema for BeatThat application
// PostgreSQL database in 3NF

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ==================== USER & AUTH ====================

model User {
  id            String    @id @default(uuid())
  email         String    @unique
  username      String    @unique
  passwordHash  String    @map("password_hash")
  role          UserRole  @default(USER)
  avatarUrl     String?   @map("avatar_url")
  bio           String?
  isActive      Boolean   @default(true) @map("is_active")
  createdAt     DateTime  @default(now()) @map("created_at")
  updatedAt     DateTime  @updatedAt @map("updated_at")

  // Relations
  loops         Loop[]
  ratings       Rating[]
  comments      Comment[]
  favorites     Favorite[]
  downloads     Download[]
  listens       Listen[]
  refreshTokens RefreshToken[]
  chatMessages  ChatMessage[]
  notifications Notification[]

  @@map("users")
}

enum UserRole {
  USER
  ADMIN
}

model RefreshToken {
  id        String   @id @default(uuid())
  token     String   @unique
  userId    String   @map("user_id")
  expiresAt DateTime @map("expires_at")
  createdAt DateTime @default(now()) @map("created_at")

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("refresh_tokens")
}

// ==================== LOOPS & AUDIO ====================

model Loop {
  id              String      @id @default(uuid())
  title           String
  slug            String      @unique
  description     String?
  bpm             Int
  key             String?     // Musical key (e.g., "Am", "C#m", "F")
  duration        Float       // Duration in seconds
  genre           String?
  
  // File paths
  originalFile    String      @map("original_file")
  previewFile     String?     @map("preview_file")
  waveformData    Json?       @map("waveform_data")
  
  // Processing status
  status          LoopStatus  @default(PENDING)
  
  // Stats (denormalized for performance)
  downloadCount   Int         @default(0) @map("download_count")
  listenCount     Int         @default(0) @map("listen_count")
  favoriteCount   Int         @default(0) @map("favorite_count")
  averageRating   Float       @default(0) @map("average_rating")
  ratingCount     Int         @default(0) @map("rating_count")
  
  // Certified download hash
  fileHash        String?     @map("file_hash")
  
  userId          String      @map("user_id")
  createdAt       DateTime    @default(now()) @map("created_at")
  updatedAt       DateTime    @updatedAt @map("updated_at")

  // Relations
  user            User        @relation(fields: [userId], references: [id], onDelete: Cascade)
  tags            LoopTag[]
  ratings         Rating[]
  comments        Comment[]
  favorites       Favorite[]
  downloads       Download[]
  listens         Listen[]

  @@index([bpm])
  @@index([key])
  @@index([genre])
  @@index([status])
  @@index([createdAt])
  @@index([downloadCount])
  @@index([averageRating])
  @@map("loops")
}

enum LoopStatus {
  PENDING     // Waiting for processing
  PROCESSING  // Currently being processed
  READY       // Ready for use
  FAILED      // Processing failed
}

model Tag {
  id        String    @id @default(uuid())
  name      String    @unique
  createdAt DateTime  @default(now()) @map("created_at")

  loops     LoopTag[]

  @@map("tags")
}

model LoopTag {
  loopId String @map("loop_id")
  tagId  String @map("tag_id")

  loop Loop @relation(fields: [loopId], references: [id], onDelete: Cascade)
  tag  Tag  @relation(fields: [tagId], references: [id], onDelete: Cascade)

  @@id([loopId, tagId])
  @@map("loop_tags")
}

// ==================== INTERACTIONS ====================

model Rating {
  id        String   @id @default(uuid())
  value     Int      // 1-5 stars
  userId    String   @map("user_id")
  loopId    String   @map("loop_id")
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
  loop Loop @relation(fields: [loopId], references: [id], onDelete: Cascade)

  @@unique([userId, loopId])
  @@map("ratings")
}

model Comment {
  id        String   @id @default(uuid())
  content   String
  userId    String   @map("user_id")
  loopId    String   @map("loop_id")
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
  loop Loop @relation(fields: [loopId], references: [id], onDelete: Cascade)

  @@index([loopId])
  @@map("comments")
}

model Favorite {
  id        String   @id @default(uuid())
  userId    String   @map("user_id")
  loopId    String   @map("loop_id")
  createdAt DateTime @default(now()) @map("created_at")

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
  loop Loop @relation(fields: [loopId], references: [id], onDelete: Cascade)

  @@unique([userId, loopId])
  @@map("favorites")
}

// ==================== ANALYTICS ====================

model Download {
  id             String   @id @default(uuid())
  userId         String   @map("user_id")
  loopId         String   @map("loop_id")
  certificateHash String  @map("certificate_hash") // Hash for certified download proof
  ipAddress      String?  @map("ip_address")
  createdAt      DateTime @default(now()) @map("created_at")

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
  loop Loop @relation(fields: [loopId], references: [id], onDelete: Cascade)

  @@index([loopId])
  @@index([createdAt])
  @@map("downloads")
}

model Listen {
  id        String   @id @default(uuid())
  userId    String   @map("user_id")
  loopId    String   @map("loop_id")
  listenDate DateTime @default(now()) @map("listen_date")

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
  loop Loop @relation(fields: [loopId], references: [id], onDelete: Cascade)

  // Ensure only 1 counted listen per user per loop per day
  @@unique([userId, loopId, listenDate])
  @@index([loopId])
  @@index([listenDate])
  @@map("listens")
}

// ==================== REALTIME FEATURES ====================

model ChatMessage {
  id        String   @id @default(uuid())
  content   String
  userId    String   @map("user_id")
  roomId    String   @map("room_id") // e.g., "general" or loop-specific chat
  createdAt DateTime @default(now()) @map("created_at")

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([roomId])
  @@index([createdAt])
  @@map("chat_messages")
}

model Notification {
  id        String           @id @default(uuid())
  type      NotificationType
  title     String
  message   String
  isRead    Boolean          @default(false) @map("is_read")
  data      Json?            // Additional data (e.g., loopId, commentId)
  userId    String           @map("user_id")
  createdAt DateTime         @default(now()) @map("created_at")

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, isRead])
  @@index([createdAt])
  @@map("notifications")
}

enum NotificationType {
  NEW_COMMENT
  NEW_RATING
  NEW_DOWNLOAD
  LOOP_PROCESSED
  SYSTEM
}
